ARM GAS  /tmp/cc3xBvjQ.s 			page 1


   1              	# 1 "src/switch.s"
   1              	
   1              	...
   0              	
   0              	
   2              	.set INT_DISABLED,           0xC0    /* Disable both FIQ and IRQ. */
   3              	.set MODE_IRQ,               0x12    /* IRQ Mode                  */
   4              	.set MODE_SVC,               0x13    /* Supervisor Mode           */
   5              	
   6              	.extern cs
   7              	.extern currentSP
   8              	.extern scheduler
   9              	
  10              	.global switch_to_current
  11              	.global SwitchingIRQHandler
  12              	.global SimpleIRQHandler
  13              	
  14              	.code 32
  15              	
  16              	/*
  17              	 *  Switch to current task without saving previous context.
  18              	 *  Used to run the first task the first time.
  19              	 *
  20              	 *  Pops the initial context setup up by the initialize_stack function.
  21              	 *  That means this function will act like a return to the task.
  22              	 *
  23              	 */
  24              	switch_to_current:
  25              	                                      /* Switch to the current task's stack. */
  26 0000 7C009FE5 	    ldr   r0, =currentSP              /* Load r0 with the address for currentSP */
  27 0004 00D090E5 	    ldr   sp, [r0]                    /* Load sp with the value stored at the address */
  28              	                                      /* sp now points to the task's stack. */
  29              	
  30              	                                      /* Set SPSR to the CPSR for the task. */
  31 0008 0100BDE8 	    ldmfd sp!, {r0}                   /* Pop the first value from the stack into r0. */
  32              	                                      /* That value was the CPSR for the task. */
  33 000c 00F06FE1 	    msr   spsr_cxsf, r0               /* Load SPSR with that CPSR value in r0. */
  34              	
  35              	                                      /* Run task. */
  36 0010 FFDFFDE8 	    ldmfd sp!, {r0-r12, lr, pc}^      /* Pop the rest of the stack setting regs and pc for the task
  37              	                                      /* Acts like a call the task. */
  38              	
  39              	
  40              	/*
  41              	 *  Simple IRQ handler that calls hello_world from the SVC mode.
  42              	 *
  43              	 *  It saves the context on the IRQ stack.
  44              	 *  Switches to the SVC mode and calls hello. Resets SVC LR after call.
  45              	 *  Switches back to IRQ mode and pops the context and returns.
  46              	 *
  47              	 *  Use this as an initial test.
  48              	 *
  49              	 */
  50              	SimpleIRQHandler:
  51 0014 04E04EE2 	    sub		lr, lr, #4                      /* LR offset to return from this exception: -4. */
  52 0018 FF5F2DE9 	    stmfd	sp!, {r0-r12, lr}               /* Push working registers. */
  53              	
ARM GAS  /tmp/cc3xBvjQ.s 			page 2


  54              	    /* Switch to SVC mode */
  55              	
  56 001c D3F021E3 	    msr		cpsr_c, #(INT_DISABLED | MODE_SVC)
  57              	
  58              	
  59 0020 00402DE9 	    stmfd  sp!, {lr}                       /* Save LR before the call. */
  60 0024 FEFFFFEB 	    bl     hello_world                     /* Call hello_world. The branch w/ link overwrites LR. *
  61 0028 0040BDE8 	    ldmfd  sp!, {lr}                       /* Restore LR after the call. */
  62              	
  63              	    /* Switch back to IRQ mode */
  64              	
  65 002c D2F021E3 	    msr    cpsr_c, #(INT_DISABLED | MODE_IRQ)
  66              	
  67 0030 FF9FFDE8 	    ldmfd  sp!, {r0-r12, pc}^              /* Pop the context and returning to interrupted code. */
  68              	
  69              	
  70              	/*
  71              	 *  Context switching interrupt handler.
  72              	 *
  73              	 *  See "Instructions for implementing the context switch.txt" for full instructions.
  74              	 *
  75              	 *
  76              	 */
  77              	SwitchingIRQHandler:
  78              	    /* IRQ mode with IRQ stack */
  79              	
  80              	    /* Adjust LR back by 4 for use later. */
  81 0034 04E04EE2 	    sub		lr, lr, #4
  82              	    /* Push working registers r0-r2 to the IRQ stack. */
  83 0038 07002DE9 	    stmfd	sp!, {r0-r2}
  84              	
  85              	    /*  We'll use r0-r2 as variables. */
  86              	    /* Save task's cpsr (stored as the IRQ's spsr) to r0 */
  87 003c 00004FE1 	    mrs		r0, spsr
  88              	    /* Save lr which is the task's pc to r1 */
  89 0040 0E10A0E1 	    mov		r1, lr
  90              	    /* Save exception's stack pointer to r2*/
  91 0044 0D20A0E1 	    mov		r2, sp
  92              	    /* Reset exception's stack by adding 12 to it. It's saved in r2 and we'll be going to svc mode 
  93 0048 0CD08DE2 	    add		sp, sp, #12
  94              	
  95              	    /* Change to SVC mode with interrupts disabled. */
  96 004c D3F021E3 	    msr		cpsr_c, #(INT_DISABLED | MODE_SVC)
  97              	
  98              	    /* SVC mode with SVC stack. This is the stack of interrupted task. */
  99              	    /* Push task's PC */
 100 0050 02002DE9 	    stmfd	sp!, {r1}
 101              	    /* Push task's LR */
 102 0054 00402DE9 	    stmfd	sp!, {lr}
 103              	    /* Push task's R3-R12 */
 104 0058 F81F2DE9 	    stmfd	sp!, {r3-r12}
 105              	
 106              	    /* We can't push R0-R2 because we've used them as variables. We need to get the values
 107              	     * they had from the IRQ stack where we stored them. To do that we can pop them off the
 108              	     * IRQ stack using R2 into R3-R5 which are now free to use since we already stored their
 109              	     * values to the task's stack.
 110              	     */
ARM GAS  /tmp/cc3xBvjQ.s 			page 3


 111              	    /* Pop 3 values from the IRQ stack using R2 as the stack pointer and load them into R3-R5. */
 112 005c 3800B2E8 	    ldmfd	r2!, {r3-r5}
 113              	    /* Push those 3 values to the task's stack */
 114 0060 38002DE9 	    stmfd	sp!, {r3-r5}
 115              	    /* Push the task's CPSR which is in R0 to the task's stack. */
 116 0064 01002DE9 	    stmfd	sp!, {r0}
 117              	    /* Call the task scheduler which sets currentSP and resets the timer. */
 118 0068 0D00A0E1 	    mov		r0, sp
 119 006c FEFFFFEB 	    bl		scheduler
 120              	
 121              	    /* Set sp to the new task's sp by reading the value stored in currentSP. */
 122 0070 0C009FE5 	    ldr		r0, =currentSP
 123 0074 00D090E5 	    ldr		sp, [r0]
 124              	
 125              	    /* Pop task's CPSR and restore it to spsr. */
 126 0078 0100BDE8 	    ldmfd	sp!, {r0}
 127 007c 00F06FE1 	    msr		spsr_cxsf, r0
 128              	
 129              	    /* spsr will be moved to cpsr when we pop the context with ldmfd */
 130              	    /* Pop task's context. Restores regs and cpsr which reenables interrupts. */
 131 0080 FFDFFDE8 	    ldmfd	sp!, {r0-r12, lr, pc}^
 131      00000000 
ARM GAS  /tmp/cc3xBvjQ.s 			page 4


DEFINED SYMBOLS
        src/switch.s:2      *ABS*:000000c0 INT_DISABLED
        src/switch.s:3      *ABS*:00000012 MODE_IRQ
        src/switch.s:4      *ABS*:00000013 MODE_SVC
        src/switch.s:24     .text:00000000 switch_to_current
        src/switch.s:77     .text:00000034 SwitchingIRQHandler
        src/switch.s:50     .text:00000014 SimpleIRQHandler
        src/switch.s:26     .text:00000000 $a
        src/switch.s:131    .text:00000084 $d
                   .debug_aranges:0000000c $d

UNDEFINED SYMBOLS
currentSP
hello_world
scheduler
